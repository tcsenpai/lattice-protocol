---
phase: 02-token-economy-decentralization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/economy/interfaces/ITokenOperations.ts
  - src/economy/interfaces/IReputationConverter.ts
  - src/economy/interfaces/IEconomicPolicy.ts
  - src/economy/interfaces/index.ts
  - src/economy/models/TokenTransaction.ts
  - src/economy/models/index.ts
  - src/economy/stubs/InMemoryTokenStore.ts
  - src/economy/stubs/index.ts
  - src/economy/index.ts
autonomous: true

must_haves:
  truths:
    - "Token interfaces define mint/burn/transfer/balance operations"
    - "Reputation converter defines EXP to token bidirectional conversion"
    - "Economic policy interface defines rate limits and emission schedule"
    - "In-memory stub allows testing token flows without persistence"
  artifacts:
    - path: "src/economy/interfaces/ITokenOperations.ts"
      provides: "Core token operation interface"
      exports: ["ITokenOperations"]
    - path: "src/economy/interfaces/IReputationConverter.ts"
      provides: "EXP/token conversion interface"
      exports: ["IReputationConverter", "ConversionRate"]
    - path: "src/economy/interfaces/IEconomicPolicy.ts"
      provides: "Economic rules interface"
      exports: ["IEconomicPolicy", "EmissionSchedule"]
    - path: "src/economy/models/TokenTransaction.ts"
      provides: "Token transaction model"
      exports: ["TokenTransaction", "TransactionType"]
    - path: "src/economy/stubs/InMemoryTokenStore.ts"
      provides: "Test implementation of token operations"
      exports: ["InMemoryTokenOperations"]
  key_links:
    - from: "src/economy/stubs/InMemoryTokenStore.ts"
      to: "src/economy/interfaces/ITokenOperations.ts"
      via: "implements"
      pattern: "implements ITokenOperations"
---

<objective>
Create token economy interfaces for mint/burn/transfer operations and EXP-to-token conversion.

Purpose: Define the token economy abstraction layer that will replace EXP. This is a DESIGN phase - interfaces and in-memory stub only, no database changes.

Output: Token operation interfaces, reputation converter interface, economic policy interface, in-memory test stub.
</objective>

<execution_context>
@/home/tcsenpai/.claude/get-shit-done/workflows/execute-plan.md
@/home/tcsenpai/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-token-economy-decentralization/02-RESEARCH.md

# Existing EXP system to abstract from
@src/modules/exp/service.ts
@src/modules/exp/repository.ts
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create token operation interfaces</name>
  <files>
    src/economy/interfaces/ITokenOperations.ts
    src/economy/interfaces/IReputationConverter.ts
    src/economy/interfaces/IEconomicPolicy.ts
    src/economy/interfaces/index.ts
  </files>
  <action>
Create core token economy interfaces following patterns from research.

**ITokenOperations.ts** - Core token operations:
```typescript
import type { TokenTransaction, TransactionType } from '../models/TokenTransaction.js';

/**
 * Token Operations Interface
 *
 * Defines the core token economy operations: mint, burn, transfer, and balance queries.
 * Implementations can be in-memory (testing), SQLite (current), or blockchain (future).
 *
 * Design Notes:
 * - Uses bigint for token amounts (18 decimal precision like ERC-20)
 * - All operations return transaction records for audit trail
 * - DID-based addressing (same as current agent identity)
 */
export interface ITokenOperations {
  /**
   * Mint new tokens to an address.
   * Only authorized minters can call this (system, rewards, migration).
   */
  mint(did: string, amount: bigint, reason: string): Promise<TokenTransaction>;

  /**
   * Burn tokens from an address.
   * Used for penalties, staking, or deflationary mechanics.
   */
  burn(did: string, amount: bigint, reason: string): Promise<TokenTransaction>;

  /**
   * Transfer tokens between addresses.
   * Returns transaction or throws if insufficient balance.
   */
  transfer(from: string, to: string, amount: bigint, memo?: string): Promise<TokenTransaction>;

  /**
   * Get token balance for an address.
   * Returns 0n for addresses that don't exist yet.
   */
  balanceOf(did: string): Promise<bigint>;

  /**
   * Get transaction history for an address.
   */
  getTransactions(did: string, options?: {
    limit?: number;
    cursor?: string;
    type?: TransactionType;
  }): Promise<TokenTransaction[]>;

  /**
   * Get total token supply (all minted - all burned).
   */
  totalSupply(): Promise<bigint>;
}
```

**IReputationConverter.ts** - EXP/token conversion:
```typescript
/**
 * Conversion rate between EXP (legacy) and tokens (new).
 */
export interface ConversionRate {
  expPerToken: number;      // How many EXP equals 1 token
  tokensPerExp: number;     // Fractional tokens per 1 EXP
  effectiveDate: number;    // Unix timestamp when rate takes effect
}

/**
 * Reputation Converter Interface
 *
 * Handles bidirectional conversion between EXP (current system) and tokens (new system).
 * Enables gradual migration where both systems can coexist.
 *
 * Migration Strategy:
 * 1. Phase 2: Define interfaces (this file)
 * 2. Phase 3: Implement dual-tracking (EXP + tokens in parallel)
 * 3. Phase 4: Migrate existing EXP balances to tokens
 * 4. Phase 5: Deprecate EXP, tokens only
 */
export interface IReputationConverter {
  /**
   * Convert EXP amount to token amount.
   * @param exp - EXP amount (integer)
   * @returns Token amount (bigint with 18 decimals)
   */
  convertEXPToTokens(exp: number): bigint;

  /**
   * Convert token amount to EXP amount.
   * Used for legacy API compatibility during migration.
   * @param tokens - Token amount (bigint with 18 decimals)
   * @returns EXP amount (integer, may lose precision)
   */
  convertTokensToEXP(tokens: bigint): number;

  /**
   * Get current conversion rate.
   */
  getConversionRate(): ConversionRate;

  /**
   * Update conversion rate (governance action).
   * Future: This will require multi-sig or DAO approval.
   */
  setConversionRate(rate: Omit<ConversionRate, 'effectiveDate'>): void;
}
```

**IEconomicPolicy.ts** - Economic rules:
```typescript
/**
 * Emission schedule defines token minting rate over time.
 */
export interface EmissionSchedule {
  /** Tokens minted per action type */
  rewardRates: {
    post: bigint;           // Tokens for creating post
    upvoteReceived: bigint; // Tokens for receiving upvote
    attestation: bigint;    // Tokens for attestation
    weeklyActivity: bigint; // Weekly engagement bonus
  };

  /** Penalty rates (negative, burns tokens) */
  penaltyRates: {
    downvoteReceived: bigint;
    spamDetected: bigint;
    spamConfirmed: bigint;
  };

  /** Max tokens ever mintable (0 = unlimited) */
  maxSupply: bigint;

  /** Current phase of emission (affects rates) */
  phase: 'bootstrap' | 'growth' | 'mature' | 'stable';
}

/**
 * Rate limit status for an address.
 */
export interface RateLimitStatus {
  remaining: number;
  resetAt: Date;
  limit: number;
}

/**
 * Sybil resistance check result.
 */
export interface SybilCheckResult {
  isTrusted: boolean;
  trustScore: number;     // 0-1, higher = more trusted
  reasons: string[];      // Why trust score is what it is
  restrictions: string[]; // What actions are restricted
}

/**
 * Economic Policy Interface
 *
 * Defines the rules governing token economics:
 * - Rate limits (prevent spam)
 * - Emission schedules (token inflation)
 * - Sybil resistance (prevent gaming)
 *
 * Phase 2: Interface definition only
 * Phase 3: Basic implementation with time-based restrictions
 * Future: Advanced Sybil resistance (PoP, social graphs)
 */
export interface IEconomicPolicy {
  /**
   * Get emission schedule for calculating rewards/penalties.
   */
  getEmissionSchedule(): EmissionSchedule;

  /**
   * Check rate limit for an action.
   */
  getRateLimit(did: string, action: 'post' | 'comment' | 'vote'): Promise<RateLimitStatus>;

  /**
   * Check Sybil resistance score for an address.
   * Phase 2: Basic implementation (account age, activity)
   * Future: Multi-factor (stake + time + reputation + social)
   */
  checkSybilResistance(did: string): Promise<SybilCheckResult>;

  /**
   * Calculate emission amount based on action and policy.
   */
  calculateEmission(action: keyof EmissionSchedule['rewardRates'], context?: {
    recipientTrustScore?: number;
    contentQuality?: number;
  }): bigint;
}
```

**index.ts** - Barrel export:
```typescript
export * from './ITokenOperations.js';
export * from './IReputationConverter.js';
export * from './IEconomicPolicy.js';
```

All interfaces have comprehensive JSDoc explaining current vs future implementation.
  </action>
  <verify>
`bun run type-check` passes. Interfaces compile without errors.
  </verify>
  <done>
ITokenOperations, IReputationConverter, IEconomicPolicy interfaces exist with TypeScript types and JSDoc.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create token transaction model</name>
  <files>
    src/economy/models/TokenTransaction.ts
    src/economy/models/index.ts
  </files>
  <action>
Create the TokenTransaction model that all token operations return.

**TokenTransaction.ts**:
```typescript
/**
 * Types of token transactions.
 */
export type TransactionType =
  | 'mint'
  | 'burn'
  | 'transfer'
  | 'reward'   // System-initiated mint for good behavior
  | 'penalty'; // System-initiated burn for bad behavior

/**
 * Token Transaction Record
 *
 * Immutable record of a token operation.
 * Used for audit trail, history, and verification.
 */
export interface TokenTransaction {
  /** Unique transaction ID (ULID) */
  id: string;

  /** Transaction type */
  type: TransactionType;

  /** Source address (null for mints) */
  from: string | null;

  /** Destination address (null for burns) */
  to: string | null;

  /** Amount transferred (always positive) */
  amount: bigint;

  /** Human-readable reason/memo */
  reason: string;

  /** Unix timestamp (seconds) */
  timestamp: number;

  /** Optional reference to source event (post ID, etc.) */
  sourceId?: string;

  /** Hash of transaction data (for verification) */
  hash?: string;
}

/**
 * Create a new token transaction record.
 * Does NOT persist - that's the job of ITokenOperations implementation.
 */
export function createTransaction(
  type: TransactionType,
  params: {
    from?: string;
    to?: string;
    amount: bigint;
    reason: string;
    sourceId?: string;
  }
): Omit<TokenTransaction, 'id' | 'timestamp' | 'hash'> {
  return {
    type,
    from: params.from ?? null,
    to: params.to ?? null,
    amount: params.amount,
    reason: params.reason,
    sourceId: params.sourceId,
  };
}

/**
 * Token balance snapshot for an address.
 */
export interface TokenBalance {
  did: string;
  balance: bigint;
  lastUpdated: number;
}

/**
 * Migration record for EXP to token conversion.
 */
export interface MigrationRecord {
  did: string;
  originalEXP: number;
  convertedTokens: bigint;
  migratedAt: number;
  transactionId: string;
}
```

**index.ts**:
```typescript
export * from './TokenTransaction.js';
```
  </action>
  <verify>
`bun run type-check` passes. TokenTransaction type is correct with bigint amounts.
  </verify>
  <done>
TokenTransaction model exists with type, from, to, amount, reason, timestamp fields. Helper functions for creating transactions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create in-memory token stub</name>
  <files>
    src/economy/stubs/InMemoryTokenStore.ts
    src/economy/stubs/index.ts
    src/economy/index.ts
  </files>
  <action>
Create in-memory implementation of ITokenOperations for testing.

**InMemoryTokenStore.ts**:
```typescript
import type { ITokenOperations } from '../interfaces/ITokenOperations.js';
import type { TokenTransaction, TransactionType } from '../models/TokenTransaction.js';
import { ulid } from '../../utils/ulid.js';
import { now } from '../../utils/time.js';

/**
 * In-Memory Token Operations
 *
 * STUB implementation for testing and development.
 * Data is lost on restart - NOT for production use.
 *
 * Usage:
 * ```typescript
 * const tokenOps = new InMemoryTokenOperations();
 * await tokenOps.mint('did:key:abc', 100n * 10n**18n, 'initial-mint');
 * const balance = await tokenOps.balanceOf('did:key:abc');
 * ```
 */
export class InMemoryTokenOperations implements ITokenOperations {
  private balances: Map<string, bigint> = new Map();
  private transactions: TokenTransaction[] = [];
  private totalMinted: bigint = 0n;
  private totalBurned: bigint = 0n;

  async mint(did: string, amount: bigint, reason: string): Promise<TokenTransaction> {
    if (amount <= 0n) {
      throw new Error('Mint amount must be positive');
    }

    const current = this.balances.get(did) ?? 0n;
    this.balances.set(did, current + amount);
    this.totalMinted += amount;

    const tx: TokenTransaction = {
      id: ulid(),
      type: 'mint',
      from: null,
      to: did,
      amount,
      reason,
      timestamp: now(),
    };

    this.transactions.push(tx);
    return tx;
  }

  async burn(did: string, amount: bigint, reason: string): Promise<TokenTransaction> {
    if (amount <= 0n) {
      throw new Error('Burn amount must be positive');
    }

    const current = this.balances.get(did) ?? 0n;
    if (current < amount) {
      throw new Error(`Insufficient balance: has ${current}, needs ${amount}`);
    }

    this.balances.set(did, current - amount);
    this.totalBurned += amount;

    const tx: TokenTransaction = {
      id: ulid(),
      type: 'burn',
      from: did,
      to: null,
      amount,
      reason,
      timestamp: now(),
    };

    this.transactions.push(tx);
    return tx;
  }

  async transfer(from: string, to: string, amount: bigint, memo?: string): Promise<TokenTransaction> {
    if (amount <= 0n) {
      throw new Error('Transfer amount must be positive');
    }

    if (from === to) {
      throw new Error('Cannot transfer to self');
    }

    const fromBalance = this.balances.get(from) ?? 0n;
    if (fromBalance < amount) {
      throw new Error(`Insufficient balance: has ${fromBalance}, needs ${amount}`);
    }

    this.balances.set(from, fromBalance - amount);
    const toBalance = this.balances.get(to) ?? 0n;
    this.balances.set(to, toBalance + amount);

    const tx: TokenTransaction = {
      id: ulid(),
      type: 'transfer',
      from,
      to,
      amount,
      reason: memo ?? 'transfer',
      timestamp: now(),
    };

    this.transactions.push(tx);
    return tx;
  }

  async balanceOf(did: string): Promise<bigint> {
    return this.balances.get(did) ?? 0n;
  }

  async getTransactions(
    did: string,
    options?: { limit?: number; cursor?: string; type?: TransactionType }
  ): Promise<TokenTransaction[]> {
    let txs = this.transactions.filter(
      tx => tx.from === did || tx.to === did
    );

    if (options?.type) {
      txs = txs.filter(tx => tx.type === options.type);
    }

    // Sort by timestamp descending (newest first)
    txs.sort((a, b) => b.timestamp - a.timestamp);

    // Apply cursor (skip to after cursor ID)
    if (options?.cursor) {
      const cursorIndex = txs.findIndex(tx => tx.id === options.cursor);
      if (cursorIndex >= 0) {
        txs = txs.slice(cursorIndex + 1);
      }
    }

    // Apply limit
    if (options?.limit) {
      txs = txs.slice(0, options.limit);
    }

    return txs;
  }

  async totalSupply(): Promise<bigint> {
    return this.totalMinted - this.totalBurned;
  }

  // Test helpers (not part of interface)
  reset(): void {
    this.balances.clear();
    this.transactions = [];
    this.totalMinted = 0n;
    this.totalBurned = 0n;
  }

  getState(): {
    balances: Map<string, bigint>;
    transactionCount: number;
    totalMinted: bigint;
    totalBurned: bigint;
  } {
    return {
      balances: new Map(this.balances),
      transactionCount: this.transactions.length,
      totalMinted: this.totalMinted,
      totalBurned: this.totalBurned,
    };
  }
}
```

**stubs/index.ts**:
```typescript
export * from './InMemoryTokenStore.js';
```

**economy/index.ts** - Main barrel export:
```typescript
/**
 * Token Economy Module
 *
 * Provides interfaces and stubs for the Lattice token economy:
 * - Token operations (mint, burn, transfer)
 * - Reputation conversion (EXP <-> tokens)
 * - Economic policy (emissions, rate limits, Sybil resistance)
 *
 * Phase 2: Interfaces and in-memory stubs only
 * Phase 3: SQLite implementation with dual-tracking
 * Phase 4: Migration from EXP to tokens
 *
 * @module economy
 */

export * from './interfaces/index.js';
export * from './models/index.js';
export * from './stubs/index.js';
```
  </action>
  <verify>
`bun run type-check` passes. InMemoryTokenOperations implements ITokenOperations. Mint/burn/transfer work correctly with bigint.
  </verify>
  <done>
InMemoryTokenOperations stub exists, implements ITokenOperations, handles mint/burn/transfer with bigint. Test helpers included. Barrel exports from src/economy/index.ts.
  </done>
</task>

</tasks>

<verification>
1. `bun run type-check` passes with no errors
2. New files exist:
   - `src/economy/interfaces/ITokenOperations.ts`
   - `src/economy/interfaces/IReputationConverter.ts`
   - `src/economy/interfaces/IEconomicPolicy.ts`
   - `src/economy/models/TokenTransaction.ts`
   - `src/economy/stubs/InMemoryTokenStore.ts`
3. InMemoryTokenOperations can mint/burn/transfer tokens
4. bigint is used for token amounts (18 decimal precision)
5. All interfaces have JSDoc explaining migration strategy
</verification>

<success_criteria>
- Token economy module exists at `src/economy/`
- ITokenOperations interface defines mint/burn/transfer/balance
- IReputationConverter interface defines EXP/token conversion
- IEconomicPolicy interface defines rate limits and emissions
- TokenTransaction model with bigint amounts
- InMemoryTokenOperations stub for testing
- Migration strategy documented in JSDoc comments
- All code passes type-check
</success_criteria>

<output>
After completion, create `.planning/phases/02-token-economy-decentralization/02-02-SUMMARY.md`
</output>
