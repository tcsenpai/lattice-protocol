---
phase: 02-token-economy-decentralization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/storage/interfaces/IContentStore.ts
  - src/storage/interfaces/IRepository.ts
  - src/storage/interfaces/index.ts
  - src/storage/adapters/SQLiteAdapter.ts
  - src/storage/adapters/index.ts
  - src/storage/cid/CIDGenerator.ts
  - src/storage/cid/index.ts
  - src/storage/index.ts
autonomous: true

must_haves:
  truths:
    - "Storage interfaces define get/put/has/delete operations"
    - "SQLite adapter implements storage interface without changing behavior"
    - "CID generator creates deterministic content identifiers"
    - "Repository pattern abstracts data access from business logic"
  artifacts:
    - path: "src/storage/interfaces/IContentStore.ts"
      provides: "Core storage abstraction interface"
      exports: ["IContentStore", "ContentStoreOptions"]
    - path: "src/storage/interfaces/IRepository.ts"
      provides: "Generic repository pattern interface"
      exports: ["IRepository"]
    - path: "src/storage/adapters/SQLiteAdapter.ts"
      provides: "SQLite implementation of IContentStore"
      exports: ["SQLiteContentStore"]
    - path: "src/storage/cid/CIDGenerator.ts"
      provides: "Content addressing utility"
      exports: ["generateCID", "verifyCID", "CIDOptions"]
  key_links:
    - from: "src/storage/adapters/SQLiteAdapter.ts"
      to: "src/storage/interfaces/IContentStore.ts"
      via: "implements"
      pattern: "implements IContentStore"
---

<objective>
Create storage abstraction layer with interfaces that allow swapping SQLite for IPFS or custom endpoints.

Purpose: Enable future migration to decentralized storage without changing business logic. This is a DESIGN phase - interfaces and stub implementations only.

Output: Storage interfaces, SQLite adapter (passthrough to existing code), CID generator for content addressing.
</objective>

<execution_context>
@/home/tcsenpai/.claude/get-shit-done/workflows/execute-plan.md
@/home/tcsenpai/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-token-economy-decentralization/02-RESEARCH.md

# Existing patterns to follow
@src/types/index.ts
@src/modules/content/repository.ts
@src/db/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create storage interface definitions</name>
  <files>
    src/storage/interfaces/IContentStore.ts
    src/storage/interfaces/IRepository.ts
    src/storage/interfaces/index.ts
  </files>
  <action>
Create storage abstraction interfaces following Repository Pattern from research.

**IContentStore.ts** - Core storage interface:
```typescript
export interface ContentStoreOptions {
  hashAlgorithm?: 'sha2-256' | 'blake3';  // For CID compatibility
  codec?: 'raw' | 'dag-json';              // Content encoding
}

export interface IContentStore {
  get(key: string): Promise<Buffer | null>;
  put(key: string, value: Buffer, options?: ContentStoreOptions): Promise<string>;
  has(key: string): Promise<boolean>;
  delete(key: string): Promise<boolean>;

  // Optional batch operations for efficiency
  getMany?(keys: string[]): Promise<Map<string, Buffer | null>>;
  putMany?(entries: Map<string, Buffer>): Promise<Map<string, string>>;
}

export type StorageBackend = 'sqlite' | 'ipfs' | 'custom-endpoint';
```

**IRepository.ts** - Generic repository interface:
```typescript
export interface IRepository<T, CreateDTO = Partial<T>> {
  findById(id: string): Promise<T | null>;
  findAll(filter?: Partial<T>, options?: { limit?: number; cursor?: string }): Promise<T[]>;
  create(data: CreateDTO): Promise<T>;
  update(id: string, data: Partial<T>): Promise<T | null>;
  delete(id: string): Promise<boolean>;
  exists(id: string): Promise<boolean>;
}
```

**index.ts** - Barrel export:
```typescript
export * from './IContentStore.js';
export * from './IRepository.js';
```

These are pure TypeScript interfaces with JSDoc comments explaining usage.
  </action>
  <verify>
`bun run type-check` passes. Files exist with exports.
  </verify>
  <done>
IContentStore and IRepository interfaces exist with proper TypeScript types and JSDoc documentation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SQLite adapter stub</name>
  <files>
    src/storage/adapters/SQLiteAdapter.ts
    src/storage/adapters/index.ts
  </files>
  <action>
Create SQLiteContentStore that implements IContentStore. This is a STUB that wraps existing database patterns.

**SQLiteAdapter.ts**:
```typescript
import type { IContentStore, ContentStoreOptions } from '../interfaces/index.js';
import { getDatabase } from '../../db/index.js';

/**
 * SQLite implementation of IContentStore.
 *
 * STUB: This adapter provides the interface for current SQLite storage.
 * In Phase 2, we keep existing repository code working while adding
 * the abstraction layer. Full migration happens in later phases.
 *
 * Future adapters (IPFSAdapter, CustomEndpointAdapter) will implement
 * the same interface for seamless backend swapping.
 */
export class SQLiteContentStore implements IContentStore {
  private tableName: string;

  constructor(tableName: string = 'content_store') {
    this.tableName = tableName;
    this.ensureTable();
  }

  private ensureTable(): void {
    const db = getDatabase();
    db.exec(`
      CREATE TABLE IF NOT EXISTS ${this.tableName} (
        key TEXT PRIMARY KEY,
        value BLOB NOT NULL,
        created_at INTEGER DEFAULT (unixepoch())
      )
    `);
  }

  async get(key: string): Promise<Buffer | null> {
    const db = getDatabase();
    const row = db.prepare(`SELECT value FROM ${this.tableName} WHERE key = ?`).get(key) as { value: Buffer } | undefined;
    return row ? row.value : null;
  }

  async put(key: string, value: Buffer, _options?: ContentStoreOptions): Promise<string> {
    const db = getDatabase();
    db.prepare(`INSERT OR REPLACE INTO ${this.tableName} (key, value) VALUES (?, ?)`).run(key, value);
    return key;  // SQLite uses provided key; IPFS would return CID
  }

  async has(key: string): Promise<boolean> {
    const db = getDatabase();
    const row = db.prepare(`SELECT 1 FROM ${this.tableName} WHERE key = ?`).get(key);
    return row !== undefined;
  }

  async delete(key: string): Promise<boolean> {
    const db = getDatabase();
    const result = db.prepare(`DELETE FROM ${this.tableName} WHERE key = ?`).run(key);
    return result.changes > 0;
  }
}
```

**index.ts** - Barrel export:
```typescript
export * from './SQLiteAdapter.js';
```

The adapter is marked as STUB with comments explaining future IPFS/custom adapters will implement the same interface.
  </action>
  <verify>
`bun run type-check` passes. SQLiteContentStore implements IContentStore without errors.
  </verify>
  <done>
SQLiteContentStore stub exists, implements IContentStore interface, wraps existing getDatabase() pattern.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create CID generator utility</name>
  <files>
    src/storage/cid/CIDGenerator.ts
    src/storage/cid/index.ts
    src/storage/index.ts
  </files>
  <action>
Create CID (Content Identifier) generator for future IPFS compatibility. Uses multiformats library (already in node_modules from existing deps).

**CIDGenerator.ts**:
```typescript
import { createHash } from 'node:crypto';

/**
 * CID Generation Options
 *
 * IMPORTANT: Changing these options creates incompatible CIDs for the same content.
 * Document any changes as breaking changes per API versioning strategy.
 */
export interface CIDOptions {
  hashAlgorithm: 'sha2-256';  // Only SHA-256 for now (IPFS default)
  version: 1;                  // CIDv1 (modern standard)
}

export const DEFAULT_CID_OPTIONS: CIDOptions = {
  hashAlgorithm: 'sha2-256',
  version: 1,
};

/**
 * Generate a CID-compatible content identifier.
 *
 * This creates a deterministic hash that follows IPFS CID conventions:
 * - Same content + same options = same CID (always)
 * - Different content = different CID
 *
 * Format: lattice-cid-v1-sha256-<hex-hash>
 *
 * Note: This is a simplified CID for Phase 2. Full multiformats/CID
 * integration happens when implementing IPFSAdapter.
 *
 * @param content - Buffer or string content to hash
 * @param options - CID generation options (use defaults for compatibility)
 */
export function generateCID(
  content: Buffer | string,
  options: CIDOptions = DEFAULT_CID_OPTIONS
): string {
  const buffer = typeof content === 'string' ? Buffer.from(content, 'utf-8') : content;
  const hash = createHash('sha256').update(buffer).digest('hex');

  // Lattice-specific CID format (will map to real CIDs in IPFS adapter)
  return `lattice-cid-v${options.version}-sha256-${hash}`;
}

/**
 * Verify that a CID matches expected content.
 *
 * @param cid - The CID to verify
 * @param content - The content that should produce this CID
 * @returns true if CID is valid for content
 */
export function verifyCID(cid: string, content: Buffer | string): boolean {
  const expectedCID = generateCID(content);
  return cid === expectedCID;
}

/**
 * Parse a Lattice CID to extract metadata.
 * Returns null if not a valid Lattice CID format.
 */
export function parseCID(cid: string): { version: number; algorithm: string; hash: string } | null {
  const match = cid.match(/^lattice-cid-v(\d+)-(\w+)-([a-f0-9]+)$/);
  if (!match) return null;

  return {
    version: parseInt(match[1], 10),
    algorithm: match[2],
    hash: match[3],
  };
}
```

**cid/index.ts**:
```typescript
export * from './CIDGenerator.js';
```

**storage/index.ts** - Main barrel export:
```typescript
/**
 * Storage Abstraction Layer
 *
 * Provides interfaces and adapters for swappable storage backends:
 * - SQLite (current, default)
 * - IPFS/Helia (future, Phase 3+)
 * - Custom HTTP endpoints (future, Phase 3+)
 *
 * @module storage
 */

export * from './interfaces/index.js';
export * from './adapters/index.js';
export * from './cid/index.js';
```

The CID format is Lattice-specific but designed to be convertible to real IPFS CIDs when IPFSAdapter is implemented.
  </action>
  <verify>
`bun run type-check` passes. `generateCID('test')` produces deterministic output. `verifyCID` returns true for matching content.
  </verify>
  <done>
CID generator exists with generateCID, verifyCID, parseCID functions. Deterministic SHA-256 hashing. Barrel exports from src/storage/index.ts.
  </done>
</task>

</tasks>

<verification>
1. `bun run type-check` passes with no errors
2. New files exist:
   - `src/storage/interfaces/IContentStore.ts`
   - `src/storage/interfaces/IRepository.ts`
   - `src/storage/adapters/SQLiteAdapter.ts`
   - `src/storage/cid/CIDGenerator.ts`
3. Interfaces are pure TypeScript (no implementation logic)
4. SQLiteAdapter implements IContentStore
5. CID generation is deterministic (same input = same output)
</verification>

<success_criteria>
- Storage abstraction layer exists at `src/storage/`
- IContentStore interface defines get/put/has/delete
- IRepository interface defines CRUD pattern
- SQLiteContentStore stub implements IContentStore
- CID generator produces deterministic content identifiers
- All code passes type-check
- JSDoc comments explain future extensibility
</success_criteria>

<output>
After completion, create `.planning/phases/02-token-economy-decentralization/02-01-SUMMARY.md`
</output>
