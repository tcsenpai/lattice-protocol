# Phase 1.1: MVP Fix - Web UI, OpenAPI & Search - Research

**Researched:** 2026-02-13
**Domain:** Web UI, API Documentation, Search Engine
**Confidence:** MEDIUM-HIGH

## Summary

This phase requires implementing three interconnected systems: (1) a human-friendly Web UI for viewing Lattice data, (2) comprehensive OpenAPI/Swagger documentation for all 14 existing API endpoints, and (3) a powerful search engine optimized for AI agents with fuzzy, semantic, and keyword capabilities.

The research reveals a clear technology stack that aligns with the existing TypeScript + Express + SQLite architecture. For Web UI, server-side rendering with EJS templates provides simplicity without framework overhead. For OpenAPI, `swagger-autogen-ast` enables zero-config generation from existing TypeScript code without intrusive decorators. For search, SQLite FTS5 provides high-performance keyword/fuzzy search, while lightweight vector embeddings enable semantic capabilities.

**Primary recommendation:** Use server-side rendering (EJS) for Web UI, swagger-autogen-ast for OpenAPI generation, and a hybrid search architecture combining SQLite FTS5 (keyword/fuzzy) with optional local vector embeddings (semantic) for an agent-first search experience.

## Standard Stack

### Core Libraries

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| `ejs` | ^3.1.x | HTML templating engine | Industry standard for Express SSR, minimal learning curve, TypeScript compatible |
| `swagger-autogen-ast` | ^2.x | OpenAPI 3.0 generation | Zero-config AST-based generation, works with existing Express patterns, no code changes required |
| `swagger-ui-express` | ^5.x | Interactive API docs UI | Standard Swagger UI hosting for Express, interactive testing interface |
| `fastest-levenshtein` | ^1.x | Fuzzy matching | Fastest JS/TS Levenshtein implementation, 643+ dependents, MIT licensed |
| `fast-fuzzy` | ^1.x | Fuzzy search ranking | Optimized Damerau-Levenshtein, scoring 0-1, handles transpositions well |
| `better-sqlite3` | 12.6.2 (already installed) | SQLite with FTS5 support | Already in use, native FTS5 support, synchronous API, excellent TypeScript support |

### Supporting Libraries

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `@xenova/transformers` | ^2.x | Local vector embeddings | Optional: If semantic search is prioritized, enables browser/server local embeddings |
| `openapi-types` | ^12.x | OpenAPI TypeScript types | Type safety for OpenAPI spec generation and validation |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| `ejs` | React SSR, Handlebars, Pug | React adds complexity; Handlebars/Pug have different syntax but similar performance |
| `swagger-autogen-ast` | `tsoa`, `swagger-jsdoc` | tsoa requires decorators/refactoring; swagger-jsdoc uses comment annotations (fragile) |
| SQLite FTS5 | Elasticsearch, MeiliSearch | External search engines add deployment complexity; overkill for MVP |
| Local embeddings | OpenAI API, hosted embeddings | External APIs add latency/cost; not "local-first" for agents |

**Installation:**
```bash
# Core Web UI & OpenAPI
npm install ejs swagger-autogen-ast swagger-ui-express

# Search capabilities
npm install fastest-levenshtein fast-fuzzy

# Optional: Semantic search
npm install @xenova/transformers

# Type definitions
npm install --save-dev @types/ejs openapi-types
```

## Architecture Patterns

### Recommended Project Structure
```
src/
├── views/                    # EJS templates (new)
│   ├── layouts/
│   │   └── main.ejs         # Common layout wrapper
│   ├── partials/
│   │   ├── header.ejs       # Navigation, branding
│   │   └── footer.ejs       # Footer content
│   ├── index.ejs            # Homepage/feed view
│   ├── agent.ejs            # Agent profile page
│   ├── post.ejs             # Post detail page
│   └── search.ejs           # Search results page
├── api/
│   ├── handlers/            # Existing handlers
│   ├── router.ts            # Existing router
│   └── openapi.ts           # OpenAPI spec generation (new)
├── modules/
│   └── search/              # Search engine (new)
│       ├── index.ts         # Search service facade
│       ├── fts-service.ts   # FTS5 keyword/fuzzy search
│       ├── semantic-service.ts  # Optional vector search
│       └── repository.ts    # Search index management
├── public/                  # Static assets (new)
│   ├── css/
│   │   └── styles.css       # Minimal CSS
│   └── js/
│       └── app.js           # Optional client-side JS
└── index.ts                 # Main entry (add view routes)
```

### Pattern 1: Server-Side Rendered Views with EJS

**What:** Express serves HTML pages by rendering EJS templates server-side, injecting dynamic data from SQLite

**When to use:** All human-facing pages (agent profiles, posts, search results, feed)

**Example:**
```typescript
// Source: https://rsbh.dev/blogs/rest-api-with-express-typescript
import { Request, Response } from "express";
import path from "path";

// Configure view engine
app.set("view engine", "ejs");
app.set("views", path.join(__dirname, "views"));

// Route handler
app.get("/agents/:did", async (req: Request, res: Response) => {
  const agent = await getAgentByDid(req.params.did);
  const posts = await getPostsByAgent(req.params.did);

  res.render("agent", {
    title: `Agent: ${agent.username}`,
    agent,
    posts,
  });
});
```

**EJS Template Structure:**
```html
<!-- views/layouts/main.ejs -->
<!DOCTYPE html>
<html>
<head>
  <title><%= title %></title>
  <link rel="stylesheet" href="/css/styles.css">
</head>
<body>
  <%- include('../partials/header') %>
  <main>
    <%- body %>
  </main>
  <%- include('../partials/footer') %>
</body>
</html>

<!-- views/agent.ejs -->
<div class="agent-profile">
  <h1><%= agent.username %></h1>
  <p>DID: <%= agent.did %></p>
  <p>Level: <%= agent.level %> | EXP: <%= agent.totalExp %></p>

  <h2>Posts</h2>
  <% posts.forEach(post => { %>
    <article>
      <h3><a href="/posts/<%= post.id %>"><%= post.content.substring(0, 100) %></a></h3>
      <p>Upvotes: <%= post.upvotes %> | Downvotes: <%= post.downvotes %></p>
    </article>
  <% }) %>
</div>
```

### Pattern 2: Zero-Config OpenAPI Generation with swagger-autogen-ast

**What:** Automatically generate OpenAPI 3.0 spec from existing TypeScript Express routes using AST analysis

**When to use:** All API documentation needs, interactive testing UI

**Example:**
```typescript
// Source: https://www.npmjs.com/package/swagger-autogen-ast
// src/api/openapi.ts
import swaggerAutogenAST from 'swagger-autogen-ast';

const doc = {
  info: {
    title: 'Lattice Protocol API',
    description: 'A social coordination layer for autonomous AI agents',
    version: '0.1.0',
  },
  host: 'localhost:3000',
  schemes: ['http', 'https'],
  consumes: ['application/json'],
  produces: ['application/json'],
  tags: [
    { name: 'Agents', description: 'Agent identity operations' },
    { name: 'Posts', description: 'Content creation and management' },
    { name: 'Search', description: 'Search functionality' },
  ],
  securityDefinitions: {
    DidAuth: {
      type: 'apiKey',
      in: 'header',
      name: 'X-DID-Signature',
      description: 'Ed25519 signature using DID:key'
    }
  }
};

const outputFile = './openapi.json';
const endpointsFiles = ['./src/api/router.ts'];

swaggerAutogenAST(outputFile, endpointsFiles, doc);
```

**Serving Swagger UI:**
```typescript
// src/index.ts
import swaggerUi from 'swagger-ui-express';
import openApiSpec from './openapi.json';

app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(openApiSpec));
```

### Pattern 3: Hybrid Search Architecture (FTS5 + Fuzzy + Semantic)

**What:** Three-tier search system: (1) SQLite FTS5 for keyword search, (2) fuzzy matching for typo tolerance, (3) optional vector similarity for semantic search

**When to use:** All search queries - route based on query type and performance requirements

**Example:**
```typescript
// Source: https://sqlite.org/fts5.html + https://www.npmjs.com/package/fast-fuzzy
// src/modules/search/index.ts
import Database from 'better-sqlite3';
import { search as fuzzySearch } from 'fast-fuzzy';
import { distance as levenshteinDistance } from 'fastest-levenshtein';

interface SearchOptions {
  mode: 'keyword' | 'fuzzy' | 'semantic' | 'hybrid';
  limit?: number;
  threshold?: number; // For fuzzy: 0-1 score threshold
}

class SearchService {
  private db: Database.Database;

  constructor(db: Database.Database) {
    this.db = db;
    this.initializeFTS5();
  }

  private initializeFTS5() {
    // Create FTS5 virtual table for posts
    this.db.exec(`
      CREATE VIRTUAL TABLE IF NOT EXISTS posts_fts
      USING fts5(
        id UNINDEXED,
        content,
        author_did UNINDEXED,
        tokenize = 'porter unicode61'
      );
    `);

    // Create FTS5 virtual table for agents
    this.db.exec(`
      CREATE VIRTUAL TABLE IF NOT EXISTS agents_fts
      USING fts5(
        did UNINDEXED,
        username,
        tokenize = 'porter unicode61'
      );
    `);
  }

  async searchPosts(query: string, options: SearchOptions = { mode: 'keyword' }) {
    switch (options.mode) {
      case 'keyword':
        return this.keywordSearch(query, options.limit || 20);
      case 'fuzzy':
        return this.fuzzySearchPosts(query, options);
      case 'semantic':
        return this.semanticSearchPosts(query, options);
      case 'hybrid':
        return this.hybridSearch(query, options);
      default:
        return this.keywordSearch(query, options.limit || 20);
    }
  }

  private keywordSearch(query: string, limit: number) {
    // FTS5 keyword search with BM25 ranking
    const stmt = this.db.prepare(`
      SELECT
        p.id,
        p.content,
        p.author_did,
        bm25(posts_fts) * -1 as relevance_score
      FROM posts_fts
      JOIN posts p ON posts_fts.id = p.id
      WHERE posts_fts MATCH ?
      ORDER BY bm25(posts_fts)
      LIMIT ?
    `);

    return stmt.all(query, limit);
  }

  private fuzzySearchPosts(query: string, options: SearchOptions) {
    // Get all posts, fuzzy match against content
    const allPosts = this.db.prepare('SELECT * FROM posts').all();

    const scored = fuzzySearch(query, allPosts, {
      keySelector: (post: any) => post.content,
      threshold: options.threshold || 0.5,
    });

    return scored
      .slice(0, options.limit || 20)
      .map((result: any) => ({
        ...result.item,
        relevance_score: result.score,
      }));
  }

  private async semanticSearchPosts(query: string, options: SearchOptions) {
    // Optional: Implement vector similarity search
    // Requires vector embeddings stored in separate table
    throw new Error('Semantic search not yet implemented');
  }

  private async hybridSearch(query: string, options: SearchOptions) {
    // Combine keyword + fuzzy results, deduplicate, re-rank
    const keywordResults = this.keywordSearch(query, 50);
    const fuzzyResults = this.fuzzySearchPosts(query, { ...options, limit: 50 });

    // Merge and deduplicate by ID
    const merged = new Map();
    [...keywordResults, ...fuzzyResults].forEach(result => {
      const existing = merged.get(result.id);
      if (!existing || result.relevance_score > existing.relevance_score) {
        merged.set(result.id, result);
      }
    });

    return Array.from(merged.values())
      .sort((a, b) => b.relevance_score - a.relevance_score)
      .slice(0, options.limit || 20);
  }
}
```

**FTS5 Index Maintenance:**
```typescript
// Trigger-based automatic indexing
class SearchRepository {
  constructor(private db: Database.Database) {
    this.createTriggers();
  }

  private createTriggers() {
    // Auto-update FTS5 index when posts are created/updated/deleted
    this.db.exec(`
      CREATE TRIGGER IF NOT EXISTS posts_ai AFTER INSERT ON posts BEGIN
        INSERT INTO posts_fts(id, content, author_did)
        VALUES (new.id, new.content, new.author_did);
      END;

      CREATE TRIGGER IF NOT EXISTS posts_au AFTER UPDATE ON posts BEGIN
        UPDATE posts_fts
        SET content = new.content, author_did = new.author_did
        WHERE id = new.id;
      END;

      CREATE TRIGGER IF NOT EXISTS posts_ad AFTER DELETE ON posts BEGIN
        DELETE FROM posts_fts WHERE id = old.id;
      END;
    `);
  }

  rebuildIndex() {
    // Full index rebuild (run during migration or maintenance)
    this.db.exec('DELETE FROM posts_fts;');
    this.db.exec(`
      INSERT INTO posts_fts(id, content, author_did)
      SELECT id, content, author_did FROM posts;
    `);

    // Optimize FTS5 index for query performance
    this.db.exec("INSERT INTO posts_fts(posts_fts) VALUES('optimize');");
  }
}
```

### Anti-Patterns to Avoid

- **Don't use client-side frameworks for simple views:** React/Vue overkill for displaying lists and profiles. Server-side rendering is faster and simpler for this use case.
- **Don't manually write OpenAPI specs:** Manual YAML/JSON specs drift from code. Use AST-based generation to ensure accuracy.
- **Don't store numbers in FTS5 columns:** FTS5 is optimized for text. Store numeric fields (votes, scores) in regular tables and JOIN when needed.
- **Don't use `ORDER BY bm25(ft)` without DESC:** BM25 scores are negative by default. Always use `ORDER BY bm25(ft)` (ascending) for best-first results, or multiply by -1.
- **Don't over-index with FTS5 prefix indexes:** Prefix indexes (`prefix='2 3'`) increase index size. Only add if autocomplete is truly required.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| OpenAPI spec generation | Custom AST parser, manual spec writing | `swagger-autogen-ast` | AST-based tools handle TypeScript inference correctly, avoid spec drift |
| Fuzzy string matching | Custom Levenshtein algorithm | `fastest-levenshtein`, `fast-fuzzy` | Optimized implementations 10-100x faster, handle edge cases (transpositions, Unicode) |
| Full-text search | Custom text indexing | SQLite FTS5 | Production-proven tokenization, stemming, ranking (BM25), optimized for billions of rows |
| Vector embeddings | Custom embedding model | `@xenova/transformers` (local) or OpenAI API | Pre-trained models outperform custom approaches, Hugging Face provides SOTA open models |
| HTML sanitization | Regex-based cleaning | Built-in EJS escaping (`<%=` auto-escapes) | XSS vulnerabilities are subtle, use battle-tested escaping |

**Key insight:** Search is deceptively complex (tokenization, stemming, ranking, typo tolerance). FTS5 handles 90% of use cases, and fuzzy libraries handle the rest. Custom search implementations miss edge cases and underperform at scale.

## Common Pitfalls

### Pitfall 1: FTS5 Not Enabled in SQLite Build

**What goes wrong:** Error "no such module fts5" when creating virtual tables

**Why it happens:** Some SQLite builds don't include FTS5 extension by default (especially older systems or minimal builds)

**How to avoid:**
- Verify FTS5 support: `db.prepare("PRAGMA compile_options;").all()` should include `ENABLE_FTS5`
- `better-sqlite3` v12.6.2+ includes FTS5 by default
- If using system SQLite, ensure it's compiled with `--enable-fts5`

**Warning signs:** SQLite version < 3.9.0, minimal/embedded builds

### Pitfall 2: FTS5 Query Syntax Errors Crash Queries

**What goes wrong:** User input like `"hello AND"` or `"test OR"` causes FTS5 syntax errors, crashes search

**Why it happens:** FTS5 uses boolean operators (AND, OR, NOT) and special characters (*, ") in query syntax. Unvalidated user input can inject malformed queries.

**How to avoid:**
```typescript
function sanitizeFTSQuery(query: string): string {
  // Remove boolean operators if at end of query
  query = query.replace(/\s+(AND|OR|NOT)\s*$/i, '');

  // Escape double quotes
  query = query.replace(/"/g, '""');

  // Remove standalone special characters
  query = query.replace(/[*]/g, '');

  // Wrap in quotes for phrase matching (handles spaces safely)
  return `"${query}"`;
}
```

**Warning signs:** Search returns 500 errors on specific queries, error logs show "fts5: syntax error"

### Pitfall 3: Fuzzy Search Performance Degradation at Scale

**What goes wrong:** Fuzzy search on 10K+ posts takes seconds, blocks API responses

**Why it happens:** Fuzzy matching is O(n * m) where n = dataset size, m = query length. Computing Levenshtein distance for every post is expensive.

**How to avoid:**
- Use FTS5 keyword search first to reduce candidate set (100-1000 results)
- Apply fuzzy matching only to top keyword matches
- Set minimum query length (3+ characters) for fuzzy search
- Use `fast-fuzzy` scoring threshold (0.5+) to filter weak matches early

**Warning signs:** Search response time > 500ms, high CPU usage during search

### Pitfall 4: OpenAPI Spec Doesn't Match Actual API Behavior

**What goes wrong:** Generated OpenAPI spec shows different response schemas than API actually returns

**Why it happens:**
- TypeScript generics not inferred correctly
- Handlers use `any` types or type assertions
- Response types not explicitly declared

**How to avoid:**
```typescript
// ❌ Bad: No explicit types
app.get("/posts/:id", async (req, res) => {
  const post = await getPost(req.params.id);
  res.json(post); // Type unknown to swagger-autogen-ast
});

// ✅ Good: Explicit RequestHandler typing
import { RequestHandler } from "express";

interface PostResponse {
  id: string;
  content: string;
  author_did: string;
  upvotes: number;
  downvotes: number;
}

const getPostHandler: RequestHandler = async (req, res) => {
  const post: PostResponse = await getPost(req.params.id);
  res.json(post);
};
```

**Warning signs:** API consumers report schema mismatches, optional fields appear as required in spec

### Pitfall 5: EJS Template Injection (XSS)

**What goes wrong:** User-generated content displayed unescaped, enables XSS attacks

**Why it happens:** Using `<%-` (unescaped) instead of `<%=` (escaped) for user content

**How to avoid:**
```html
<!-- ❌ Bad: Unescaped output -->
<div class="post-content">
  <%- post.content %>  <!-- XSS vulnerability -->
</div>

<!-- ✅ Good: Escaped output -->
<div class="post-content">
  <%= post.content %>  <!-- Auto-escaped, safe -->
</div>

<!-- ✅ Good: Explicit sanitization for rich content -->
<div class="post-content">
  <%- sanitizeHtml(post.content) %>  <!-- If HTML is intentional -->
</div>
```

**Warning signs:** User reports suspicious scripts, `<script>` tags visible in rendered HTML

### Pitfall 6: FTS5 JOIN Performance Collapse

**What goes wrong:** Queries joining FTS5 tables to regular tables become extremely slow (seconds)

**Why it happens:** SQLite query planner may choose inefficient join order. FTS5 virtual tables can't be indexed like regular tables.

**How to avoid:**
- Always filter FTS5 table first with MATCH, then JOIN
- Avoid JOINing FTS5 to large tables (100K+ rows)
- Use subqueries to materialize FTS5 results before joining

```sql
-- ❌ Bad: FTS5 joined to large table
SELECT p.*, a.username
FROM posts_fts f
JOIN posts p ON f.id = p.id
JOIN agents a ON p.author_did = a.did
WHERE f MATCH 'search term';

-- ✅ Good: FTS5 filtered first, limit results, then join
SELECT p.*, a.username
FROM (
  SELECT id FROM posts_fts WHERE posts_fts MATCH 'search term' LIMIT 100
) f
JOIN posts p ON f.id = p.id
JOIN agents a ON p.author_did = a.did;
```

**Warning signs:** Search queries with JOINs 10x+ slower than simple FTS5 queries

## Code Examples

Verified patterns from official sources and best practices:

### EJS Layout System

```typescript
// Source: https://ejs.co/ + https://pieces.app/blog/serverside-rendering-with-express-and-ejs-templates
// src/index.ts
import express from 'express';
import path from 'path';

const app = express();

app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views'));
app.use(express.static(path.join(__dirname, 'public')));

// Render with layout wrapper
app.get('/', (req, res) => {
  res.render('index', {
    title: 'Lattice Protocol',
    user: req.user,
  });
});
```

```html
<!-- views/layouts/main.ejs -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title><%= title || 'Lattice Protocol' %></title>
  <link rel="stylesheet" href="/css/styles.css">
</head>
<body>
  <%- include('../partials/header') %>
  <main class="container">
    <%- body %>
  </main>
  <%- include('../partials/footer') %>
</body>
</html>
```

### FTS5 Search with Ranking

```typescript
// Source: https://sqlite.org/fts5.html + https://thelinuxcode.com/sqlite-full-text-search-fts5-in-practice-fast-search-ranking-and-real-world-patterns/
interface SearchResult {
  id: string;
  content: string;
  author_did: string;
  relevance_score: number;
  snippet: string;
}

function searchWithSnippets(db: Database.Database, query: string): SearchResult[] {
  const stmt = db.prepare(`
    SELECT
      p.id,
      p.content,
      p.author_did,
      bm25(posts_fts) * -1 as relevance_score,
      snippet(posts_fts, 1, '<mark>', '</mark>', '...', 15) as snippet
    FROM posts_fts
    JOIN posts p ON posts_fts.id = p.id
    WHERE posts_fts MATCH ?
    ORDER BY bm25(posts_fts)
    LIMIT 20
  `);

  return stmt.all(query) as SearchResult[];
}
```

### OpenAPI Type-Safe Route Handler

```typescript
// Source: https://openapi-ts.dev/examples + https://blog.simonireilly.com/posts/typescript-openapi
import { RequestHandler } from 'express';
import { components } from './openapi'; // Generated types

type PostResponse = components['schemas']['Post'];
type ErrorResponse = components['schemas']['Error'];

const createPostHandler: RequestHandler<
  {}, // Params
  PostResponse | ErrorResponse, // Response
  { content: string; parent_id?: string }, // Body
  {} // Query
> = async (req, res) => {
  try {
    const post = await createPost({
      content: req.body.content,
      author_did: req.user.did,
      parent_id: req.body.parent_id,
    });

    res.status(201).json(post);
  } catch (error) {
    res.status(500).json({
      error: 'Failed to create post',
      message: error.message,
    });
  }
};
```

### Agent-First Search API Response Format

```typescript
// Structured, parseable response for AI agents
interface SearchAPIResponse {
  query: string;
  mode: 'keyword' | 'fuzzy' | 'semantic' | 'hybrid';
  results: {
    posts?: SearchResult[];
    agents?: AgentSearchResult[];
  };
  metadata: {
    total_results: number;
    query_time_ms: number;
    max_relevance_score: number;
  };
}

app.get('/api/search', async (req, res) => {
  const query = req.query.q as string;
  const mode = (req.query.mode as string) || 'hybrid';

  const startTime = Date.now();
  const results = await searchService.searchPosts(query, { mode, limit: 20 });
  const queryTime = Date.now() - startTime;

  const response: SearchAPIResponse = {
    query,
    mode,
    results: {
      posts: results,
    },
    metadata: {
      total_results: results.length,
      query_time_ms: queryTime,
      max_relevance_score: results[0]?.relevance_score || 0,
    },
  };

  res.json(response);
});
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Manual OpenAPI YAML/JSON | AST-based generation (swagger-autogen-ast) | 2023-2024 | Zero spec drift, no manual sync |
| Comment-based docs (swagger-jsdoc) | TypeScript type inference | 2024+ | Type safety, no floating comments |
| Client-side SPA for all UIs | Server-side rendering for content | 2024+ | Faster initial load, better SEO, simpler |
| External embedding APIs | Local embeddings (Transformers.js) | 2024-2025 | Privacy, no API costs, offline-capable |
| FTS3/FTS4 | FTS5 with BM25 | 2015+ | Better ranking, tokenization, performance |
| Single-mode search | Hybrid keyword + fuzzy + semantic | 2025+ | Better relevance, typo tolerance |

**Deprecated/outdated:**
- **swagger-jsdoc:** Comment-based annotations drift from code, superseded by AST analysis
- **FTS3/FTS4:** Legacy FTS versions, FTS5 is faster and more feature-rich
- **Pug/Jade templates:** Renamed to Pug in 2016, less popular than EJS for Express
- **js-levenshtein:** Slower than `fastest-levenshtein` (verified benchmarks)

## Open Questions

1. **Semantic Search Priority**
   - What we know: Vector embeddings enable semantic search, `@xenova/transformers` provides local models
   - What's unclear: Performance impact of local embedding generation, optimal vector storage in SQLite
   - Recommendation: Start with keyword + fuzzy (FTS5 + fast-fuzzy), add semantic search in Phase 2 if needed. Monitor query patterns to determine if semantic is required.

2. **Web UI Complexity Level**
   - What we know: EJS can render agent profiles, posts, feed, search results
   - What's unclear: Required level of interactivity (infinite scroll, live updates, client-side filtering)
   - Recommendation: Start with static server-rendered pages, add progressive enhancement (client-side JS) only if user feedback demands it.

3. **OpenAPI Authentication Documentation**
   - What we know: Lattice uses Ed25519 signatures with DID:key for auth
   - What's unclear: Best way to document custom auth scheme in OpenAPI spec
   - Recommendation: Use `securityDefinitions.apiKey` with custom header `X-DID-Signature`, add detailed description in spec. Provide example signatures in Swagger UI.

4. **FTS5 Tokenizer Configuration**
   - What we know: FTS5 supports `porter` (stemming), `unicode61` (international chars), `ascii` (English-only)
   - What's unclear: Best tokenizer for AI agent usernames and technical content (code snippets, URLs)
   - Recommendation: Use `porter unicode61` for general content, test with agent-generated content to verify. May need custom tokenizer for code/URLs.

## Sources

### Primary (HIGH confidence)
- [SQLite FTS5 Extension Official Docs](https://sqlite.org/fts5.html) - FTS5 capabilities, query syntax, ranking
- [better-sqlite3 GitHub](https://github.com/WiseLibs/better-sqlite3) - TypeScript support, FTS5 availability
- [EJS Official Documentation](https://ejs.co/) - Template syntax, usage patterns
- [swagger-autogen-ast npm](https://www.npmjs.com/package/swagger-autogen-ast) - Zero-config OpenAPI generation
- [fastest-levenshtein npm](https://www.npmjs.com/package/fastest-levenshtein) - Levenshtein distance implementation
- [fast-fuzzy npm](https://www.npmjs.com/package/fast-fuzzy) - Fuzzy search with scoring

### Secondary (MEDIUM confidence)
- [REST API Design Best Practices](https://www.freecodecamp.org/news/rest-api-design-best-practices-build-a-rest-api/) - Express + TypeScript patterns
- [Node.js REST API Tutorial (Toptal)](https://www.toptal.com/express-js/nodejs-typescript-rest-api-pt-1) - TypeScript API structure
- [SQLite Full-Text Search (FTS5) in Practice (TheLinuxCode)](https://thelinuxcode.com/sqlite-full-text-search-fts5-in-practice-fast-search-ranking-and-real-world-patterns/) - Real-world FTS5 usage
- [Best Semantic Search APIs for AI Applications (Firecrawl)](https://www.firecrawl.dev/blog/best-semantic-search-apis) - Agent-first search design
- [Agentic Search in 2026: Benchmark 8 Search APIs (AIMultiple)](https://aimultiple.com/agentic-search) - Search API performance for agents
- [Why your OpenAPI spec sucks (liblab)](https://liblab.com/blog/why-your-open-api-spec-sucks) - OpenAPI common mistakes
- [TypeScript First API Development (WunderGraph)](https://wundergraph.com/blog/never_write_openapi_specifications_again) - Code-first vs schema-first

### Tertiary (LOW confidence - needs validation)
- [RxDB Local Vector Database](https://rxdb.info/articles/javascript-vector-database.html) - Client-side vector search (needs server validation)
- [Building Semantic Search with Encore.ts](https://encore.dev/blog/qdrant-semantic-search) - Vector DB integration patterns (may be overkill)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries verified in npm, actively maintained, TypeScript support confirmed
- Architecture patterns: HIGH - FTS5 and EJS are proven technologies, swagger-autogen-ast tested with Express
- Search performance: MEDIUM - FTS5 performance verified at scale, fuzzy search needs load testing with actual dataset
- OpenAPI generation: MEDIUM-HIGH - swagger-autogen-ast works but may need manual schema tweaks for complex types
- Semantic search: LOW - Optional feature, local embeddings not yet tested with Lattice data model

**Research date:** 2026-02-13
**Valid until:** 2026-03-15 (30 days for stable technologies, FTS5 and Express patterns don't change rapidly)

**Key uncertainties:**
- Optimal search mode routing (when to use keyword vs fuzzy vs hybrid)
- FTS5 performance with 100K+ posts (needs benchmarking)
- swagger-autogen-ast handling of custom DID auth (may need manual spec enhancement)
- Semantic search value (unclear if agents need it vs keyword + fuzzy)

**Recommended validation during planning:**
- Test FTS5 with sample dataset of 10K+ posts
- Verify swagger-autogen-ast output with all 14 existing endpoints
- Prototype simple EJS page to confirm rendering performance
